## 附錄 E：版本

> [appendix-05-editions.md](https://github.com/rust-lang/book/blob/master/src/appendix-05-editions.md)
> <br />
> commit 70a82519e48b8a61f98cabb8ff443d1b21962fea

早在第一章，我們見過 `cargo new` 在 *Cargo.toml* 中增加了一些有關 `edition` 的元數據。本附錄將解釋其意義！

Rust 語言和編譯器有一個為期 6 周的發布循環。這意味著用戶會穩定得到新功能的更新。其他程式語言發布大更新但不甚頻繁；Rust 選擇更為頻繁的發布小更新。一段時間之後，所有這些小更新會日積月累。不過隨著小更新逐次的發布，或許很難回過頭來感嘆：“哇，從 Rust 1.10 到 Rust 1.31，Rust 的變化真大！”

每兩到三年，Rust 團隊會生成一個新的 Rust **版本**（*edition*）。每一個版本會結合已經落地的功能，並提供一個清晰的帶有完整更新文件和工具的功能包。新版本會作為常規的 6 周發布過程的一部分發布。

這為不同的人群提供了不同的功能：

* 對於活躍的 Rust 用戶，其將增量的修改與易於理解的功能包相結合。
* 對於非用戶，它表明發布了一些重大進展，這意味著 Rust 可能變得值得一試。
* 對於 Rust 自身開發者，其提供了項目整體的集合點。

在本文件編寫時，Rust 有兩個版本：Rust 2015 和 Rust 2018。本書基於 Rust 2018 edition 編寫。

*Cargo.toml* 中的 `edition` 欄位表明代碼應該使用哪個版本編譯。如果該欄位不存在，其預設為 `2015` 以提供後向相容性。

每個項目都可以選擇不同於默認的 2015 edition 的版本。這樣，版本可能會包含不相容的修改，比如新增關鍵字可能會與代碼中的標識符衝突並導致錯誤。不過除非選擇相容這些修改，（舊）代碼仍將能夠編譯，即便升級了 Rust 編譯器的版本。

所有 Rust 編譯器都支持任何之前存在的編譯器版本，並可以連結任何支持版本的 crate。編譯器修改只影響最初的解析代碼的過程。因此，如果你使用 Rust 2015 而某個依賴使用 Rust 2018，你的項目仍舊能夠編譯並使用該依賴。反之，若項目使用 Rust 2018 而依賴使用 Rust 2015 亦可工作。

有一點需要明確：大部分功能在所有版本中都能使用。開發者使用任何 Rust 版本將能繼續接收最新穩定版的改進。然而在一些情況，主要是增加了新關鍵字的時候，則可能出現了只能用於新版本的功能。只需切換版本即可利用新版本的功能。

請查看 [Edition Guide](https://rust-lang-nursery.github.io/edition-guide/) 了解更多細節，這是一個完全介紹版本的書籍，包括如何通過 `cargo fix` 自動將代碼遷移到新版本。
