# 無畏並發

> [ch16-00-concurrency.md](https://github.com/rust-lang/book/blob/master/src/ch16-00-concurrency.md) <br>
> commit 1fedfc4b96c2017f64ecfcf41a0a07e2e815f24f

安全且高效的處理並發編程是 Rust 的另一個主要目標。**並發編程**（_Concurrent programming_），代表程序的不同部分相互獨立的執行，而 **並行編程**（_parallel programming_）代表程序不同部分於同時執行，這兩個概念隨著計算機越來越多的利用多處理器的優勢時顯得越來越重要。由於歷史原因，在此類上下文中編程一直是困難且容易出錯的：Rust 希望能改變這一點。

起初，Rust 團隊認為確保記憶體安全和防止並發問題是兩個分別需要不同方法應對的挑戰。隨著時間的推移，團隊發現所有權和類型系統是一系列解決記憶體安全 **和** 並發問題的強有力的工具！透過利用所有權和類型檢查，在 Rust 中很多並發錯誤都是 **編譯時** 錯誤，而非運行時錯誤。因此，相比花費大量時間嘗試重現運行時並發 bug 出現的特定情況，Rust 會拒絕編譯不正確的代碼並提供解釋問題的錯誤訊息。因此，你可以在開發時修復代碼，而不是在部署到生產環境後修復代碼。我們給 Rust 的這一部分取了一個綽號 **無畏並發**（_fearless concurrency_）。無畏並發令你的代碼免於出現詭異的 bug 並可以輕鬆重構且無需擔心會引入新的 bug。

> 注意：出於簡潔的考慮，我們將很多問題歸類為 **並發**，而不是更準確的區分 **並發和（或）並行**。如果這是一本專注於並發和/或並行的書，我們肯定會更加精確的。對於本章，當我們談到 **並發** 時，請自行腦內替換為 **並發和（或）並行**。

很多語言所提供的處理並發問題的解決方法都非常有特色。例如，Erlang 有著優雅的消息傳遞並發功能，但只有模糊不清的在執行緒間共享狀態的方法。對於高級語言來說，只實現可能解決方案的子集是一個合理的策略，因為高級語言所許諾的價值來源於犧牲一些控制來換取抽象。然而對於底層語言則期望提供在任何給定的情況下有著最高的性能且對硬體有更少的抽象。因此，Rust 提供了多種工具，以符合實際情況和需求的方式來為問題建模。

如下是本章將要涉及到的內容：

- 如何創建執行緒來同時執行多段代碼。
- **消息傳遞**（_Message passing_）並發，其中通道（channel）被用來在執行緒間傳遞消息。
- **共享狀態**（_Shared state_）並發，其中多個執行緒可以訪問同一片數據。
- `Sync` 和 `Send` trait，將 Rust 的並發保證擴展到用戶定義的以及標準庫提供的類型中。
