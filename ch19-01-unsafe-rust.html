<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>不安全的 Rust - Rust 程式設計語言 繁體中文版</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Rust 程式設計語言 繁體中文版">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="ferris.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="title-page.html">Rust 程式設計語言</a></li><li class="chapter-item expanded affix "><a href="foreword.html">前言</a></li><li class="chapter-item expanded affix "><a href="ch00-00-introduction.html">介紹</a></li><li class="chapter-item expanded "><a href="ch01-00-getting-started.html"><strong aria-hidden="true">1.</strong> 入門指南</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch01-01-installation.html"><strong aria-hidden="true">1.1.</strong> 安裝</a></li><li class="chapter-item expanded "><a href="ch01-02-hello-world.html"><strong aria-hidden="true">1.2.</strong> Hello, World!</a></li><li class="chapter-item expanded "><a href="ch01-03-hello-cargo.html"><strong aria-hidden="true">1.3.</strong> Hello, Cargo!</a></li></ol></li><li class="chapter-item expanded "><a href="ch02-00-guessing-game-tutorial.html"><strong aria-hidden="true">2.</strong> 猜猜看遊戲教學</a></li><li class="chapter-item expanded "><a href="ch03-00-common-programming-concepts.html"><strong aria-hidden="true">3.</strong> 常見編程概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch03-01-variables-and-mutability.html"><strong aria-hidden="true">3.1.</strong> 變數與可變性</a></li><li class="chapter-item expanded "><a href="ch03-02-data-types.html"><strong aria-hidden="true">3.2.</strong> 數據類型</a></li><li class="chapter-item expanded "><a href="ch03-03-how-functions-work.html"><strong aria-hidden="true">3.3.</strong> 函數如何工作</a></li><li class="chapter-item expanded "><a href="ch03-04-comments.html"><strong aria-hidden="true">3.4.</strong> 注釋</a></li><li class="chapter-item expanded "><a href="ch03-05-control-flow.html"><strong aria-hidden="true">3.5.</strong> 控制流</a></li></ol></li><li class="chapter-item expanded "><a href="ch04-00-understanding-ownership.html"><strong aria-hidden="true">4.</strong> 認識所有權</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch04-01-what-is-ownership.html"><strong aria-hidden="true">4.1.</strong> 什麼是所有權？</a></li><li class="chapter-item expanded "><a href="ch04-02-references-and-borrowing.html"><strong aria-hidden="true">4.2.</strong> 引用與借用</a></li><li class="chapter-item expanded "><a href="ch04-03-slices.html"><strong aria-hidden="true">4.3.</strong> Slices</a></li></ol></li><li class="chapter-item expanded "><a href="ch05-00-structs.html"><strong aria-hidden="true">5.</strong> 使用結構體來組織相關聯的數據</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch05-01-defining-structs.html"><strong aria-hidden="true">5.1.</strong> 定義並實例化結構體</a></li><li class="chapter-item expanded "><a href="ch05-02-example-structs.html"><strong aria-hidden="true">5.2.</strong> 一個使用結構體的範例程序</a></li><li class="chapter-item expanded "><a href="ch05-03-method-syntax.html"><strong aria-hidden="true">5.3.</strong> 方法語法</a></li></ol></li><li class="chapter-item expanded "><a href="ch06-00-enums.html"><strong aria-hidden="true">6.</strong> 枚舉與模式匹配</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch06-01-defining-an-enum.html"><strong aria-hidden="true">6.1.</strong> 定義枚舉</a></li><li class="chapter-item expanded "><a href="ch06-02-match.html"><strong aria-hidden="true">6.2.</strong> match 控制流運算符</a></li><li class="chapter-item expanded "><a href="ch06-03-if-let.html"><strong aria-hidden="true">6.3.</strong> if let 簡潔控制流</a></li></ol></li><li class="chapter-item expanded "><a href="ch07-00-managing-growing-projects-with-packages-crates-and-modules.html"><strong aria-hidden="true">7.</strong> 使用包、Crate 和模組管理不斷增長的項目</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch07-01-packages-and-crates.html"><strong aria-hidden="true">7.1.</strong> 包和 crate</a></li><li class="chapter-item expanded "><a href="ch07-02-defining-modules-to-control-scope-and-privacy.html"><strong aria-hidden="true">7.2.</strong> 定義模組來控制作用域與私有性</a></li><li class="chapter-item expanded "><a href="ch07-03-paths-for-referring-to-an-item-in-the-module-tree.html"><strong aria-hidden="true">7.3.</strong> 路徑用於引用模組樹中的項</a></li><li class="chapter-item expanded "><a href="ch07-04-bringing-paths-into-scope-with-the-use-keyword.html"><strong aria-hidden="true">7.4.</strong> 使用 use 關鍵字將名稱引入作用域</a></li><li class="chapter-item expanded "><a href="ch07-05-separating-modules-into-different-files.html"><strong aria-hidden="true">7.5.</strong> 將模組分割進不同文件</a></li></ol></li><li class="chapter-item expanded "><a href="ch08-00-common-collections.html"><strong aria-hidden="true">8.</strong> 常見集合</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch08-01-vectors.html"><strong aria-hidden="true">8.1.</strong> vector</a></li><li class="chapter-item expanded "><a href="ch08-02-strings.html"><strong aria-hidden="true">8.2.</strong> 字串</a></li><li class="chapter-item expanded "><a href="ch08-03-hash-maps.html"><strong aria-hidden="true">8.3.</strong> 哈希 map</a></li></ol></li><li class="chapter-item expanded "><a href="ch09-00-error-handling.html"><strong aria-hidden="true">9.</strong> 錯誤處理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch09-01-unrecoverable-errors-with-panic.html"><strong aria-hidden="true">9.1.</strong> panic! 與不可恢復的錯誤</a></li><li class="chapter-item expanded "><a href="ch09-02-recoverable-errors-with-result.html"><strong aria-hidden="true">9.2.</strong> Result 與可恢復的錯誤</a></li><li class="chapter-item expanded "><a href="ch09-03-to-panic-or-not-to-panic.html"><strong aria-hidden="true">9.3.</strong> panic! 還是不 panic!</a></li></ol></li><li class="chapter-item expanded "><a href="ch10-00-generics.html"><strong aria-hidden="true">10.</strong> 泛型、trait 與生命週期</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch10-01-syntax.html"><strong aria-hidden="true">10.1.</strong> 泛型數據類型</a></li><li class="chapter-item expanded "><a href="ch10-02-traits.html"><strong aria-hidden="true">10.2.</strong> trait：定義共享的行為</a></li><li class="chapter-item expanded "><a href="ch10-03-lifetime-syntax.html"><strong aria-hidden="true">10.3.</strong> 生命週期與引用有效性</a></li></ol></li><li class="chapter-item expanded "><a href="ch11-00-testing.html"><strong aria-hidden="true">11.</strong> 測試</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch11-01-writing-tests.html"><strong aria-hidden="true">11.1.</strong> 編寫測試</a></li><li class="chapter-item expanded "><a href="ch11-02-running-tests.html"><strong aria-hidden="true">11.2.</strong> 運行測試</a></li><li class="chapter-item expanded "><a href="ch11-03-test-organization.html"><strong aria-hidden="true">11.3.</strong> 測試的組織結構</a></li></ol></li><li class="chapter-item expanded "><a href="ch12-00-an-io-project.html"><strong aria-hidden="true">12.</strong> 一個 I/O 項目：構建命令行程序</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch12-01-accepting-command-line-arguments.html"><strong aria-hidden="true">12.1.</strong> 接受命令行參數</a></li><li class="chapter-item expanded "><a href="ch12-02-reading-a-file.html"><strong aria-hidden="true">12.2.</strong> 讀取文件</a></li><li class="chapter-item expanded "><a href="ch12-03-improving-error-handling-and-modularity.html"><strong aria-hidden="true">12.3.</strong> 重構以改進模組化與錯誤處理</a></li><li class="chapter-item expanded "><a href="ch12-04-testing-the-librarys-functionality.html"><strong aria-hidden="true">12.4.</strong> 採用測試驅動開發完善庫的功能</a></li><li class="chapter-item expanded "><a href="ch12-05-working-with-environment-variables.html"><strong aria-hidden="true">12.5.</strong> 處理環境變數</a></li><li class="chapter-item expanded "><a href="ch12-06-writing-to-stderr-instead-of-stdout.html"><strong aria-hidden="true">12.6.</strong> 將錯誤訊息輸出到標準錯誤而不是標準輸出</a></li></ol></li><li class="chapter-item expanded "><a href="ch13-00-functional-features.html"><strong aria-hidden="true">13.</strong> Rust 中的函數式語言功能：疊代器與閉包</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch13-01-closures.html"><strong aria-hidden="true">13.1.</strong> 閉包：可以捕獲其環境的匿名函數</a></li><li class="chapter-item expanded "><a href="ch13-02-iterators.html"><strong aria-hidden="true">13.2.</strong> 使用疊代器處理元素序列</a></li><li class="chapter-item expanded "><a href="ch13-03-improving-our-io-project.html"><strong aria-hidden="true">13.3.</strong> 改進之前的 I/O 項目</a></li><li class="chapter-item expanded "><a href="ch13-04-performance.html"><strong aria-hidden="true">13.4.</strong> 性能比較：循環對疊代器</a></li></ol></li><li class="chapter-item expanded "><a href="ch14-00-more-about-cargo.html"><strong aria-hidden="true">14.</strong> 更多關於 Cargo 和 Crates.io 的內容</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch14-01-release-profiles.html"><strong aria-hidden="true">14.1.</strong> 採用發布配置自訂構建</a></li><li class="chapter-item expanded "><a href="ch14-02-publishing-to-crates-io.html"><strong aria-hidden="true">14.2.</strong> 將 crate 發布到 Crates.io</a></li><li class="chapter-item expanded "><a href="ch14-03-cargo-workspaces.html"><strong aria-hidden="true">14.3.</strong> Cargo 工作空間</a></li><li class="chapter-item expanded "><a href="ch14-04-installing-binaries.html"><strong aria-hidden="true">14.4.</strong> 使用 cargo install 從 Crates.io 安裝二進位制文件</a></li><li class="chapter-item expanded "><a href="ch14-05-extending-cargo.html"><strong aria-hidden="true">14.5.</strong> Cargo 自訂擴展命令</a></li></ol></li><li class="chapter-item expanded "><a href="ch15-00-smart-pointers.html"><strong aria-hidden="true">15.</strong> 智慧指針</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch15-01-box.html"><strong aria-hidden="true">15.1.</strong> Box<T> 指向堆上數據，並且可確定大小</a></li><li class="chapter-item expanded "><a href="ch15-02-deref.html"><strong aria-hidden="true">15.2.</strong> 通過 Deref trait 將智慧指針當作常規引用處理</a></li><li class="chapter-item expanded "><a href="ch15-03-drop.html"><strong aria-hidden="true">15.3.</strong> Drop Trait 運行清理代碼</a></li><li class="chapter-item expanded "><a href="ch15-04-rc.html"><strong aria-hidden="true">15.4.</strong> Rc<T> 引用計數智慧指針</a></li><li class="chapter-item expanded "><a href="ch15-05-interior-mutability.html"><strong aria-hidden="true">15.5.</strong> RefCell<T> 與內部可變性模式</a></li><li class="chapter-item expanded "><a href="ch15-06-reference-cycles.html"><strong aria-hidden="true">15.6.</strong> 引用循環與記憶體洩漏是安全的</a></li></ol></li><li class="chapter-item expanded "><a href="ch16-00-concurrency.html"><strong aria-hidden="true">16.</strong> 無畏並發</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch16-01-threads.html"><strong aria-hidden="true">16.1.</strong> 執行緒</a></li><li class="chapter-item expanded "><a href="ch16-02-message-passing.html"><strong aria-hidden="true">16.2.</strong> 消息傳遞</a></li><li class="chapter-item expanded "><a href="ch16-03-shared-state.html"><strong aria-hidden="true">16.3.</strong> 共享狀態</a></li><li class="chapter-item expanded "><a href="ch16-04-extensible-concurrency-sync-and-send.html"><strong aria-hidden="true">16.4.</strong> 可擴展的並發：Sync 與 Send</a></li></ol></li><li class="chapter-item expanded "><a href="ch17-00-oop.html"><strong aria-hidden="true">17.</strong> Rust 的面向對象編程特性</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch17-01-what-is-oo.html"><strong aria-hidden="true">17.1.</strong> 面向對象語言的特點</a></li><li class="chapter-item expanded "><a href="ch17-02-trait-objects.html"><strong aria-hidden="true">17.2.</strong> 為使用不同類型的值而設計的 trait 對象</a></li><li class="chapter-item expanded "><a href="ch17-03-oo-design-patterns.html"><strong aria-hidden="true">17.3.</strong> 面向對象設計模式的實現</a></li></ol></li><li class="chapter-item expanded "><a href="ch18-00-patterns.html"><strong aria-hidden="true">18.</strong> 模式用來匹配值的結構</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch18-01-all-the-places-for-patterns.html"><strong aria-hidden="true">18.1.</strong> 所有可能會用到模式的位置</a></li><li class="chapter-item expanded "><a href="ch18-02-refutability.html"><strong aria-hidden="true">18.2.</strong> Refutability：何時模式可能會匹配失敗</a></li><li class="chapter-item expanded "><a href="ch18-03-pattern-syntax.html"><strong aria-hidden="true">18.3.</strong> 模式的全部語法</a></li></ol></li><li class="chapter-item expanded "><a href="ch19-00-advanced-features.html"><strong aria-hidden="true">19.</strong> 高級特徵</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch19-01-unsafe-rust.html" class="active"><strong aria-hidden="true">19.1.</strong> 不安全的 Rust</a></li><li class="chapter-item expanded "><a href="ch19-03-advanced-traits.html"><strong aria-hidden="true">19.2.</strong> 高級 trait</a></li><li class="chapter-item expanded "><a href="ch19-04-advanced-types.html"><strong aria-hidden="true">19.3.</strong> 高級類型</a></li><li class="chapter-item expanded "><a href="ch19-05-advanced-functions-and-closures.html"><strong aria-hidden="true">19.4.</strong> 高級函數與閉包</a></li><li class="chapter-item expanded "><a href="ch19-06-macros.html"><strong aria-hidden="true">19.5.</strong> 宏</a></li></ol></li><li class="chapter-item expanded "><a href="ch20-00-final-project-a-web-server.html"><strong aria-hidden="true">20.</strong> 最後的項目: 構建多執行緒 web server</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch20-01-single-threaded.html"><strong aria-hidden="true">20.1.</strong> 單執行緒 web server</a></li><li class="chapter-item expanded "><a href="ch20-02-multithreaded.html"><strong aria-hidden="true">20.2.</strong> 將單執行緒 server 變為多執行緒 server</a></li><li class="chapter-item expanded "><a href="ch20-03-graceful-shutdown-and-cleanup.html"><strong aria-hidden="true">20.3.</strong> 優雅停機與清理</a></li></ol></li><li class="chapter-item expanded "><a href="appendix-00.html"><strong aria-hidden="true">21.</strong> 附錄</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-01-keywords.html"><strong aria-hidden="true">21.1.</strong> A - 關鍵字</a></li><li class="chapter-item expanded "><a href="appendix-02-operators.html"><strong aria-hidden="true">21.2.</strong> B - 運算符與符號</a></li><li class="chapter-item expanded "><a href="appendix-03-derivable-traits.html"><strong aria-hidden="true">21.3.</strong> C - 可派生的 trait</a></li><li class="chapter-item expanded "><a href="appendix-04-useful-development-tools.html"><strong aria-hidden="true">21.4.</strong> D - 實用開發工具</a></li><li class="chapter-item expanded "><a href="appendix-05-editions.html"><strong aria-hidden="true">21.5.</strong> E - 版本</a></li><li class="chapter-item expanded "><a href="appendix-06-translation.html"><strong aria-hidden="true">21.6.</strong> F - 本書譯本</a></li><li class="chapter-item expanded "><a href="appendix-07-nightly-rust.html"><strong aria-hidden="true">21.7.</strong> G - Rust 是如何開發的與 “Nightly Rust”</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Rust 程式設計語言 繁體中文版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2><a class="header" href="#不安全-rust" id="不安全-rust">不安全 Rust</a></h2>
<blockquote>
<p><a href="https://github.com/rust-lang/book/blob/master/src/ch19-01-unsafe-rust.md">ch19-01-unsafe-rust.md</a>
<br>
commit 28fa3d15b0bc67ea5e79eeff2198e4277fc61baf</p>
</blockquote>
<p>目前為止討論過的代碼都有 Rust 在編譯時會強制執行的記憶體安全保證。然而，Rust 還隱藏有第二種語言，它不會強制執行這類記憶體安全保證：這被稱為 <strong>不安全 Rust</strong>（<em>unsafe Rust</em>）。它與常規 Rust 代碼無異，但是會提供額外的超級力量。</p>
<p>不安全 Rust 之所以存在，是因為靜態分析本質上是保守的。當編譯器嘗試確定一段代碼是否支持某個保證時，拒絕一些有效的程序比接受無效程序要好一些。這必然意味著有時代碼可能是合法的，但是 Rust 不這麼認為！在這種情況下，可以使用不安全代碼告訴編譯器，“相信我，我知道我在幹什麼。”這麼做的缺點就是你只能靠自己了：如果不安全代碼出錯了，比如解引用空指針，可能會導致不安全的記憶體使用。</p>
<p>另一個 Rust 存在不安全一面的原因是：底層計算機硬體固有的不安全性。如果 Rust 不允許進行不安全操作，那麼有些任務則根本完成不了。Rust 需要能夠進行像直接與操作系統交互，甚至於編寫你自己的操作系統這樣的底層系統編程！這也是 Rust 語言的目標之一。讓我們看看不安全 Rust 能做什麼，和怎麼做。</p>
<h3><a class="header" href="#不安全的超級力量" id="不安全的超級力量">不安全的超級力量</a></h3>
<p>可以通過 <code>unsafe</code> 關鍵字來切換到不安全 Rust，接著可以開啟一個新的存放不安全代碼的塊。這裡有五類可以在不安全 Rust 中進行而不能用於安全 Rust 的操作，它們稱之為 “不安全的超級力量。” 這些超級力量是：</p>
<ul>
<li>解引用裸指針</li>
<li>調用不安全的函數或方法</li>
<li>訪問或修改可變靜態變數</li>
<li>實現不安全 trait</li>
<li>訪問 <code>union</code> 的欄位</li>
</ul>
<p>有一點很重要，<code>unsafe</code> 並不會關閉借用檢查器或禁用任何其他 Rust 安全檢查：如果在不安全代碼中使用引用，它仍會被檢查。<code>unsafe</code> 關鍵字只是提供了那五個不會被編譯器檢查記憶體安全的功能。你仍然能在不安全塊中獲得某種程度的安全。</p>
<p>再者，<code>unsafe</code> 不意味著塊中的代碼就一定是危險的或者必然導致記憶體安全問題：其意圖在於作為程式設計師你將會確保 <code>unsafe</code> 塊中的代碼以有效的方式訪問記憶體。</p>
<p>人是會犯錯誤的，錯誤總會發生，不過通過要求這五類操作必須位於標記為 <code>unsafe</code> 的塊中，就能夠知道任何與記憶體安全相關的錯誤必定位於 <code>unsafe</code> 塊內。保持 <code>unsafe</code> 塊儘可能小，如此當之後調查記憶體 bug 時就會感謝你自己了。</p>
<p>為了儘可能隔離不安全代碼，將不安全代碼封裝進一個安全的抽象並提供安全 API 是一個好主意，當我們學習不安全函數和方法時會討論到。標準庫的一部分被實現為在被評審過的不安全代碼之上的安全抽象。這個技術防止了 <code>unsafe</code> 洩露到所有你或者用戶希望使用由 <code>unsafe</code> 代碼實現的功能的地方，因為使用其安全抽象是安全的。</p>
<p>讓我們按順序依次介紹上述五個超級力量，同時我們會看到一些提供不安全代碼的安全介面的抽象。</p>
<h3><a class="header" href="#解引用裸指針" id="解引用裸指針">解引用裸指針</a></h3>
<p>回到第四章的 <a href="ch04-02-references-and-borrowing.html#dangling-references">“懸垂引用”</a>  部分，那裡提到了編譯器會確保引用總是有效的。不安全 Rust 有兩個被稱為 <strong>裸指針</strong>（<em>raw pointers</em>）的類似於引用的新類型。和引用一樣，裸指針是不可變或可變的，分別寫作 <code>*const T</code> 和 <code>*mut T</code>。這裡的星號不是解引用運算符；它是類型名稱的一部分。在裸指針的上下文中，<strong>不可變</strong> 意味著指針解引用之後不能直接賦值。</p>
<p>與引用和智慧指針的區別在於，記住裸指針</p>
<ul>
<li>允許忽略借用規則，可以同時擁有不可變和可變的指針，或多個指向相同位置的可變指針</li>
<li>不保證指向有效的記憶體</li>
<li>允許為空</li>
<li>不能實現任何自動清理功能</li>
</ul>
<p>通過去掉 Rust 強加的保證，你可以放棄安全保證以換取性能或使用另一個語言或硬體介面的能力，此時 Rust 的保證並不適用。</p>
<p>範例 19-1 展示了如何從引用同時創建不可變和可變裸指針。</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-1: 透過引用創建裸指針</span></p>
<p>注意這裡沒有引入 <code>unsafe</code> 關鍵字。可以在安全代碼中 <strong>創建</strong> 裸指針，只是不能在不安全塊之外 <strong>解引用</strong> 裸指針，稍後便會看到。</p>
<p>這裡使用 <code>as</code> 將不可變和可變引用強轉為對應的裸指針類型。因為直接從保證安全的引用來創建他們，可以知道這些特定的裸指針是有效，但是不能對任何裸指針做出如此假設。</p>
<p>接下來會創建一個不能確定其有效性的裸指針，範例 19-2 展示了如何創建一個指向任意記憶體地址的裸指針。嘗試使用任意記憶體是未定義行為：此地址可能有數據也可能沒有，編譯器可能會最佳化掉這個記憶體訪問，或者程序可能會出現段錯誤（segmentation fault）。通常沒有好的理由編寫這樣的代碼，不過卻是可行的：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let address = 0x012345usize;
let r = address as *const i32;
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-2: 創建指向任意記憶體地址的裸指針</span></p>
<p>記得我們說過可以在安全代碼中創建裸指針，不過不能 <strong>解引用</strong> 裸指針和讀取其指向的數據。現在我們要做的就是對裸指針使用解引用運算符 <code>*</code>，這需要一個 <code>unsafe</code> 塊，如範例 19-3 所示：</p>
<pre><pre class="playground"><code class="language-rust unsafe">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut num = 5;

let r1 = &amp;num as *const i32;
let r2 = &amp;mut num as *mut i32;

unsafe {
    println!(&quot;r1 is: {}&quot;, *r1);
    println!(&quot;r2 is: {}&quot;, *r2);
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-3: 在 <code>unsafe</code> 塊中解引用裸指針</span></p>
<p>創建一個指針不會造成任何危險；只有當訪問其指向的值時才有可能遇到無效的值。</p>
<p>還需注意範例 19-1 和 19-3 中創建了同時指向相同記憶體位置 <code>num</code> 的裸指針 <code>*const i32</code> 和 <code>*mut i32</code>。相反如果嘗試創建 <code>num</code> 的不可變和可變引用，這將無法編譯因為 Rust 的所有權規則不允許擁有可變引用的同時擁有不可變引用。通過裸指針，就能夠同時創建同一地址的可變指針和不可變指針，若通過可變指針修改數據，則可能潛在造成數據競爭。請多加小心！</p>
<p>既然存在這麼多的危險，為何還要使用裸指針呢？一個主要的應用場景便是調用 C 代碼介面，這在下一部分 <a href="#calling-an-unsafe-function-or-method">“調用不安全函數或方法”</a>  中會講到。另一個場景是構建借用檢查器無法理解的安全抽象。讓我們先介紹不安全函數，接著看一看使用不安全代碼的安全抽象的例子。</p>
<h3><a class="header" href="#調用不安全函數或方法" id="調用不安全函數或方法">調用不安全函數或方法</a></h3>
<p>第二類要求使用不安全塊的操作是調用不安全函數。不安全函數和方法與常規函數方法十分類似，除了其開頭有一個額外的 <code>unsafe</code>。在此上下文中，關鍵字<code>unsafe</code>表示該函數具有調用時需要滿足的要求，而 Rust 不會保證滿足這些要求。通過在 <code>unsafe</code> 塊中調用不安全函數，表明我們已經閱讀過此函數的文件並對其是否滿足函數自身的契約負責。</p>
<p>如下是一個沒有做任何操作的不安全函數 <code>dangerous</code> 的例子：</p>
<pre><pre class="playground"><code class="language-rust unsafe">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe fn dangerous() {}

unsafe {
    dangerous();
}
<span class="boring">}
</span></code></pre></pre>
<p>必須在一個單獨的 <code>unsafe</code> 塊中調用 <code>dangerous</code> 函數。如果嘗試不使用 <code>unsafe</code> 塊調用 <code>dangerous</code>，則會得到一個錯誤：</p>
<pre><code class="language-text">error[E0133]: call to unsafe function requires unsafe function or block
 --&gt;
  |
4 |     dangerous();
  |     ^^^^^^^^^^^ call to unsafe function
</code></pre>
<p>透過將 <code>dangerous</code> 調用插入 <code>unsafe</code> 塊中，我們就向 Rust 保證了我們已經閱讀過函數的文件，理解如何正確使用，並驗證過其滿足函數的契約。</p>
<p>不安全函數體也是有效的 <code>unsafe</code> 塊，所以在不安全函數中進行另一個不安全操作時無需新增額外的 <code>unsafe</code> 塊。</p>
<h4><a class="header" href="#創建不安全代碼的安全抽象" id="創建不安全代碼的安全抽象">創建不安全代碼的安全抽象</a></h4>
<p>僅僅因為函數包含不安全代碼並不意味著整個函數都需要標記為不安全的。事實上，將不安全代碼封裝進安全函數是一個常見的抽象。作為一個例子，標準庫中的函數，<code>split_at_mut</code>，它需要一些不安全代碼，讓我們探索如何可以實現它。這個安全函數定義於可變 slice 之上：它獲取一個 slice 並從給定的索引參數開始將其分為兩個 slice。<code>split_at_mut</code> 的用法如範例 19-4 所示：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut v = vec![1, 2, 3, 4, 5, 6];

let r = &amp;mut v[..];

let (a, b) = r.split_at_mut(3);

assert_eq!(a, &amp;mut [1, 2, 3]);
assert_eq!(b, &amp;mut [4, 5, 6]);
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-4: 使用安全的 <code>split_at_mut</code> 函數</span></p>
<p>這個函數無法只通過安全 Rust 實現。一個嘗試可能看起來像範例 19-5，它不能編譯。出於簡單考慮，我們將 <code>split_at_mut</code> 實現為函數而不是方法，並只處理 <code>i32</code> 值而非泛型 <code>T</code> 的 slice。</p>
<pre><code class="language-rust ignore does_not_compile">fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();

    assert!(mid &lt;= len);

    (&amp;mut slice[..mid],
     &amp;mut slice[mid..])
}
</code></pre>
<p><span class="caption">範例 19-5: 嘗試只使用安全 Rust 來實現 <code>split_at_mut</code></span></p>
<p>此函數首先獲取 slice 的長度，然後通過檢查參數是否小於或等於這個長度來斷言參數所給定的索引位於 slice 當中。該斷言意味著如果傳入的索引比要分割的 slice 的索引更大，此函數在嘗試使用這個索引前 panic。</p>
<p>之後我們在一個元組中返回兩個可變的 slice：一個從原始 slice 的開頭直到 <code>mid</code> 索引，另一個從 <code>mid</code> 直到原 slice 的結尾。</p>
<p>如果嘗試編譯範例 19-5 的代碼，會得到一個錯誤：</p>
<pre><code class="language-text">error[E0499]: cannot borrow `*slice` as mutable more than once at a time
 --&gt;
  |
6 |     (&amp;mut slice[..mid],
  |           ----- first mutable borrow occurs here
7 |      &amp;mut slice[mid..])
  |           ^^^^^ second mutable borrow occurs here
8 | }
  | - first borrow ends here
</code></pre>
<p>Rust 的借用檢查器不能理解我們要借用這個 slice 的兩個不同部分：它只知道我們借用了同一個 slice 兩次。本質上借用 slice 的不同部分是可以的，因為結果兩個 slice 不會重疊，不過 Rust 還沒有智慧到能夠理解這些。當我們知道某些事是可以的而 Rust 不知道的時候，就是觸及不安全代碼的時候了</p>
<p>範例 19-6 展示了如何使用 <code>unsafe</code> 塊，裸指針和一些不安全函數調用來實現 <code>split_at_mut</code>：</p>
<pre><pre class="playground"><code class="language-rust unsafe">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice;

fn split_at_mut(slice: &amp;mut [i32], mid: usize) -&gt; (&amp;mut [i32], &amp;mut [i32]) {
    let len = slice.len();
    let ptr = slice.as_mut_ptr();

    assert!(mid &lt;= len);

    unsafe {
        (slice::from_raw_parts_mut(ptr, mid),
         slice::from_raw_parts_mut(ptr.add(mid), len - mid))
    }
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-6: 在 <code>split_at_mut</code> 函數的實現中使用不安全代碼</span></p>
<p>回憶第四章的 <a href="ch04-03-slices.html#the-slice-type">“Slice 類型” </a> 部分，slice 是一個指向一些數據的指針，並帶有該 slice 的長度。可以使用 <code>len</code> 方法獲取 slice 的長度，使用 <code>as_mut_ptr</code> 方法訪問 slice 的裸指針。在這個例子中，因為有一個 <code>i32</code> 值的可變 slice，<code>as_mut_ptr</code> 返回一個 <code>*mut i32</code> 類型的裸指針，儲存在 <code>ptr</code> 變數中。</p>
<p>我們保持索引 <code>mid</code> 位於 slice 中的斷言。接著是不安全代碼：<code>slice::from_raw_parts_mut</code> 函數獲取一個裸指針和一個長度來創建一個 slice。這裡使用此函數從 <code>ptr</code> 中創建了一個有 <code>mid</code> 個項的 slice。之後在 <code>ptr</code> 上調用 <code>add</code> 方法並使用 <code>mid</code> 作為參數來獲取一個從 <code>mid</code> 開始的裸指針，使用這個裸指針並以 <code>mid</code> 之後項的數量為長度創建一個 slice。</p>
<p><code>slice::from_raw_parts_mut</code> 函數是不安全的因為它獲取一個裸指針，並必須確信這個指針是有效的。裸指針上的 <code>add</code> 方法也是不安全的，因為其必須確信此地址偏移量也是有效的指針。因此必須將 <code>slice::from_raw_parts_mut</code> 和 <code>add</code> 放入 <code>unsafe</code> 塊中以便能調用它們。通過觀察代碼，和增加 <code>mid</code> 必然小於等於 <code>len</code> 的斷言，我們可以說 <code>unsafe</code> 塊中所有的裸指針將是有效的 slice 中數據的指針。這是一個可以接受的 <code>unsafe</code> 的恰當用法。</p>
<p>注意無需將 <code>split_at_mut</code> 函數的結果標記為 <code>unsafe</code>，並可以在安全 Rust 中調用此函數。我們創建了一個不安全代碼的安全抽象，其代碼以一種安全的方式使用了 <code>unsafe</code> 代碼，因為其只從這個函數訪問的數據中創建了有效的指針。</p>
<p>與此相對，範例 19-7 中的 <code>slice::from_raw_parts_mut</code> 在使用 slice 時很有可能會崩潰。這段代碼獲取任意記憶體地址並創建了一個長為一萬的 slice：</p>
<pre><pre class="playground"><code class="language-rust unsafe">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::slice;

let address = 0x01234usize;
let r = address as *mut i32;

let slice: &amp;[i32] = unsafe {
    slice::from_raw_parts_mut(r, 10000)
};
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-7: 透過任意記憶體地址創建 slice</span></p>
<p>我們並不擁有這個任意地址的記憶體，也不能保證這段代碼創建的 slice 包含有效的 <code>i32</code> 值。試圖使用臆測為有效的 <code>slice</code> 會導致未定義的行為。</p>
<h4><a class="header" href="#使用-extern-函數調用外部代碼" id="使用-extern-函數調用外部代碼">使用 <code>extern</code> 函數調用外部代碼</a></h4>
<p>有時你的 Rust 代碼可能需要與其他語言編寫的代碼交互。為此 Rust 有一個關鍵字，<code>extern</code>，有助於創建和使用 <strong>外部函數介面</strong>（<em>Foreign Function Interface</em>， FFI）。外部函數介面是一個程式語言用以定義函數的方式，其允許不同（外部）程式語言調用這些函數。</p>
<p>範例 19-8 展示了如何集成 C 標準庫中的 <code>abs</code> 函數。<code>extern</code> 塊中聲明的函數在 Rust 代碼中總是不安全的。因為其他語言不會強制執行 Rust 的規則且 Rust 無法檢查它們，所以確保其安全是程式設計師的責任：</p>
<p><span class="filename">檔案名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust unsafe">extern &quot;C&quot; {
    fn abs(input: i32) -&gt; i32;
}

fn main() {
    unsafe {
        println!(&quot;Absolute value of -3 according to C: {}&quot;, abs(-3));
    }
}
</code></pre></pre>
<p><span class="caption">範例 19-8: 聲明並調用另一個語言中定義的 <code>extern</code> 函數</span></p>
<p>在 <code>extern &quot;C&quot;</code> 塊中，列出了我們希望能夠調用的另一個語言中的外部函數的簽名和名稱。<code>&quot;C&quot;</code> 部分定義了外部函數所使用的 <strong>應用二進位制介面</strong>（<em>application binary interface</em>，ABI） —— ABI 定義了如何在匯編語言層面調用此函數。<code>&quot;C&quot;</code> ABI 是最常見的，並遵循 C 程式語言的 ABI。</p>
<blockquote>
<h4><a class="header" href="#從其它語言調用-rust-函數" id="從其它語言調用-rust-函數">從其它語言調用 Rust 函數</a></h4>
<p>也可以使用 <code>extern</code> 來創建一個允許其他語言調用 Rust 函數的介面。不同於 <code>extern</code> 塊，就在 <code>fn</code> 關鍵字之前增加 <code>extern</code> 關鍵字並指定所用到的 ABI。還需增加 <code>#[no_mangle]</code> 註解來告訴 Rust 編譯器不要 mangle 此函數的名稱。<em>Mangling</em> 發生於當編譯器將我們指定的函數名修改為不同的名稱時，這會增加用於其他編譯過程的額外訊息，不過會使其名稱更難以閱讀。每一個程式語言的編譯器都會以稍微不同的方式 mangle 函數名，所以為了使 Rust 函數能在其他語言中指定，必須禁用 Rust 編譯器的 name mangling。</p>
<p>在如下的例子中，一旦其編譯為動態庫並從 C 語言中連結，<code>call_from_c</code> 函數就能夠在 C 代碼中訪問：</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern &quot;C&quot; fn call_from_c() {
    println!(&quot;Just called a Rust function from C!&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p><code>extern</code> 的使用無需 <code>unsafe</code>。</p>
</blockquote>
<h3><a class="header" href="#訪問或修改可變靜態變數" id="訪問或修改可變靜態變數">訪問或修改可變靜態變數</a></h3>
<p>目前為止全書都儘量避免討論 <strong>全局變數</strong>（<em>global variables</em>），Rust 確實支持他們，不過這對於 Rust 的所有權規則來說是有問題的。如果有兩個執行緒訪問相同的可變全局變數，則可能會造成數據競爭。</p>
<p>全局變數在 Rust 中被稱為 <strong>靜態</strong>（<em>static</em>）變數。範例 19-9 展示了一個擁有字串 slice 值的靜態變數的聲明和應用：</p>
<p><span class="filename">檔案名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust">static HELLO_WORLD: &amp;str = &quot;Hello, world!&quot;;

fn main() {
    println!(&quot;name is: {}&quot;, HELLO_WORLD);
}
</code></pre></pre>
<p><span class="caption">範例 19-9: 定義和使用一個不可變靜態變數</span></p>
<p><code>static</code> 變數類似於第三章 <a href="ch03-01-variables-and-mutability.html#differences-between-variables-and-constants">“變數和常量的區別”</a>  部分討論的常量。通常靜態變數的名稱採用 <code>SCREAMING_SNAKE_CASE</code> 寫法，並 <strong>必須</strong> 標註變數的類型，在這個例子中是 <code>&amp;'static str</code>。靜態變數只能儲存擁有 <code>'static</code> 生命週期的引用，這意味著 Rust 編譯器可以自己計算出其生命週期而無需顯式標註。訪問不可變靜態變數是安全的。</p>
<p>常量與不可變靜態變數可能看起來很類似，不過一個微妙的區別是靜態變數中的值有一個固定的記憶體地址。使用這個值總是會訪問相同的地址。另一方面，常量則允許在任何被用到的時候複製其數據。</p>
<p>常量與靜態變數的另一個區別在於靜態變數可以是可變的。訪問和修改可變靜態變數都是 <strong>不安全</strong> 的。範例 19-10 展示了如何聲明、訪問和修改名為 <code>COUNTER</code> 的可變靜態變數：</p>
<p><span class="filename">檔案名: src/main.rs</span></p>
<pre><pre class="playground"><code class="language-rust unsafe">static mut COUNTER: u32 = 0;

fn add_to_count(inc: u32) {
    unsafe {
        COUNTER += inc;
    }
}

fn main() {
    add_to_count(3);

    unsafe {
        println!(&quot;COUNTER: {}&quot;, COUNTER);
    }
}
</code></pre></pre>
<p><span class="caption">範例 19-10: 讀取或修改一個可變靜態變數是不安全的</span></p>
<p>就像常規變數一樣，我們使用 <code>mut</code> 關鍵來指定可變性。任何讀寫 <code>COUNTER</code> 的代碼都必須位於 <code>unsafe</code> 塊中。這段代碼可以編譯並如期列印出 <code>COUNTER: 3</code>，因為這是單執行緒的。擁有多個執行緒訪問 <code>COUNTER</code> 則可能導致數據競爭。</p>
<p>擁有可以全局訪問的可變數據，難以保證不存在數據競爭，這就是為何 Rust 認為可變靜態變數是不安全的。任何可能的情況，請優先使用第十六章討論的並發技術和執行緒安全智慧指針，這樣編譯器就能檢測不同執行緒間的數據訪問是否是安全的。</p>
<h3><a class="header" href="#實現不安全-trait" id="實現不安全-trait">實現不安全 trait</a></h3>
<p>最後一個只能用在 <code>unsafe</code> 中的操作是實現不安全 trait。當至少有一個方法中包含編譯器不能驗證的不變數時 trait 是不安全的。可以在 <code>trait</code> 之前增加 <code>unsafe</code> 關鍵字將 trait 聲明為 <code>unsafe</code>，同時 trait 的實現也必須標記為 <code>unsafe</code>，如範例 19-11 所示：</p>
<pre><pre class="playground"><code class="language-rust unsafe">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>unsafe trait Foo {
    // methods go here
}

unsafe impl Foo for i32 {
    // method implementations go here
}
<span class="boring">}
</span></code></pre></pre>
<p><span class="caption">範例 19-11: 定義並實現不安全 trait</span></p>
<p>通過 <code>unsafe impl</code>，我們承諾將保證編譯器所不能驗證的不變數。</p>
<p>作為一個例子，回憶第十六章 <a href="ch16-04-extensible-concurrency-sync-and-send.html#extensible-concurrency-with-the-sync-and-send-traits">“使用 <code>Sync</code> 和 <code>Send</code> trait 的可擴展並發”</a>  部分中的 <code>Sync</code> 和 <code>Send</code> 標記 trait，編譯器會自動為完全由 <code>Send</code> 和 <code>Sync</code> 類型組成的類型自動實現他們。如果實現了一個包含一些不是 <code>Send</code> 或 <code>Sync</code> 的類型，比如裸指針，並希望將此類型標記為 <code>Send</code> 或 <code>Sync</code>，則必須使用 <code>unsafe</code>。Rust 不能驗證我們的類型保證可以安全的跨執行緒發送或在多執行緒間訪問，所以需要我們自己進行檢查並通過 <code>unsafe</code> 表明。</p>
<h3><a class="header" href="#訪問聯合體中的欄位" id="訪問聯合體中的欄位">訪問聯合體中的欄位</a></h3>
<p><code>union</code> 和 <code>struct</code> 類似，但是在一個實例中同時只能使用一個聲明的欄位。聯合體主要用於和 C 代碼中的聯合體交互。訪問聯合體的欄位是不安全的，因為 Rust 無法保證當前存儲在聯合體實例中數據的類型。可以查看<a href="https://doc.rust-lang.org/reference/items/unions.html">參考文件</a>了解有關聯合體的更多訊息。</p>
<h3><a class="header" href="#何時使用不安全代碼" id="何時使用不安全代碼">何時使用不安全代碼</a></h3>
<p>使用 <code>unsafe</code> 來進行這五個操作（超級力量）之一是沒有問題的，甚至是不需要深思熟慮的，不過使得 <code>unsafe</code> 代碼正確也實屬不易，因為編譯器不能幫助保證記憶體安全。當有理由使用 <code>unsafe</code> 代碼時，是可以這麼做的，透過使用顯式的 <code>unsafe</code> 標註使得在出現錯誤時易於追蹤問題的源頭。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="ch19-00-advanced-features.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="ch19-03-advanced-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="ch19-00-advanced-features.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="ch19-03-advanced-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="ferris.js"></script>
        

        

    </body>
</html>
